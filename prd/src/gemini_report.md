INFORME TÉCNICO DE ARQUITECTURA: SISTEMA DE DELIMITACIÓN AVANZADA, MENSAJERÍA CONTEXTUAL Y SEGREGACIÓN DE DATOS READ-ONLY PARA FG FITNESS PERFORMANCE1. Visión Ejecutiva y Alcance EstratégicoEste documento técnico constituye la definición formal y el análisis de ingeniería para la implementación del módulo de Delimitación Avanzada y Soporte Contextual dentro del ecosistema digital de FG Fitness Performance. Este análisis responde a la necesidad imperativa de transformar la infraestructura actual, caracterizada por procesos manuales y desconectados 1, en una plataforma de alto rendimiento, segura y centrada en la experiencia del usuario (UX) bajo una filosofía estricta de "Solo Lectura" (Read-Only) para el cliente final.La premisa fundamental de este desarrollo es la eliminación de la fricción cognitiva y operativa. En el estado actual, el soporte al cliente carece de contexto; cuando un usuario tiene una duda sobre un ejercicio, debe describir manualmente el problema, el ejercicio y sus parámetros, lo que genera una brecha de comunicación ineficiente. La solución propuesta introduce una arquitectura de Mensajería Contextualizada mediante la inyección de identificadores únicos estables (Stable UUIDs) en estructuras de datos complejas (JSONB), permitiendo que cada interacción de soporte lleve consigo una "huella digital" técnica del elemento consultado.1Este informe detalla la arquitectura de base de datos en PostgreSQL (Supabase), las políticas de seguridad a nivel de fila (Row Level Security - RLS), la lógica de enrutamiento de mensajes basada en roles, y la estrategia de sincronización "Offline-First" necesaria para garantizar la operatividad en entornos de baja conectividad típicos de los gimnasios.1.1 Objetivos Técnicos de la DelimitaciónLa delimitación avanzada no es simplemente una restricción de permisos; es una arquitectura de flujo de datos diseñada para garantizar la integridad y la especificidad.ObjetivoDescripción TécnicaImpacto en Negocio (ROI)Inmutabilidad del Cliente (Read-Only)Implementación de políticas RLS que prohíben estrictamente operaciones INSERT, UPDATE o DELETE por parte del cliente en tablas de planes (assigned_workouts, assigned_nutrition).Elimina errores de usuario, corrupción de planes y asegura que la "Fuente de Verdad" sea siempre el Coach.Contextualización GranularInyección de context_id en cada objeto dentro de los arrays JSONB de ejercicios y comidas.Reduce el tiempo de resolución de dudas al eliminar la necesidad de que el usuario explique "de qué está hablando".Enrutamiento InteligenteLógica de backend que analiza el context_type (Nutrición vs. Workout) para dirigir el mensaje al especialista adecuado (Nutriólogo vs. Entrenador).Optimiza el flujo de trabajo del personal, evitando que los entrenadores reciban dudas de dietas y viceversa.Persistencia OfflineArquitectura de replicación local (SQLite) con sincronización diferida para mensajería y lectura de planes.Garantiza que el "Botón de Duda" funcione incluso sin red, enviando la consulta apenas se restablezca la conexión.32. Arquitectura de Datos e Ingeniería de EsquemaLa base de la solución reside en un diseño de esquema robusto en Supabase (PostgreSQL). A diferencia de los modelos relacionales tradicionales altamente normalizados, la naturaleza variable de los planes de entrenamiento (circuitos, biseries, AMRAPs) y nutrición exige un enfoque híbrido utilizando tipos de datos JSONB para el contenido de los planes, manteniendo relaciones estrictas para la asignación y la mensajería.52.1 El Desafío de la Identidad en Estructuras SemiestructuradasEl requerimiento central es: "cada ejercicio y plan alimenticio tendrá un botón de duda... con id de la duda de donde viene".En una base de datos relacional pura, tendríamos una tabla workout_exercises con un id primario. Sin embargo, para optimizar el rendimiento de lectura móvil y la flexibilidad de las plantillas, FG Fitness utiliza columnas JSONB (structure) en las tablas assigned_workouts y assigned_nutrition.1El Problema Técnico:Dentro de un objeto JSONB, los elementos (ejercicios dentro de un día, alimentos dentro de una comida) son anónimos o dependen de su posición en el array (índice). Si referenciamos una duda al "Índice 0" del "Día 1", y posteriormente el coach reordena el plan, la duda quedará vinculada al ejercicio incorrecto. Esto es inaceptable para un sistema de soporte contextual.La Solución: Inyección de IDs Estables (Stable Context IDs)Se implementará un "Middleware de Ingesta" o un Trigger de Base de Datos que procese cualquier inserción o actualización en las columnas JSONB. Este proceso recorrerá el árbol JSON y asignará un UUID v4 a cada nodo accionable (bloque, ejercicio, comida) que no tenga uno.Estructura JSONB Enriquecida (Propuesta Definitiva):JSON// Columna: structure (jsonb) en assigned_workouts
{
  "weeks":
            }
          ]
        }
      ]
    }
  ]
}
Esta estructura garantiza que el "Botón de Duda" en el frontend siempre tenga un exercise_instance_id único y persistente para enviar al chat, independientemente de si el ejercicio cambia de orden o de día.72.2 Definición del Esquema de Mensajería PolimórficaPara soportar la comunicación contextual, la tabla de mensajes no puede ser una simple relación lineal. Debe ser capaz de referenciar polimórficamente diferentes entidades (un ejercicio de workout, una comida de nutrición, o un check-in).Se propone la creación de la tabla support_messages con metadatos contextuales enriquecidos.Esquema DDL (Data Definition Language):SQLCREATE TYPE support_context_type AS ENUM ('workout_exercise', 'nutrition_meal', 'check_in', 'general');

CREATE TABLE public.support_threads (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    client_id UUID REFERENCES auth.users(id) NOT NULL,
    coach_id UUID REFERENCES auth.users(id), -- Asignado dinámicamente según el contexto
    status TEXT DEFAULT 'open' CHECK (status IN ('open', 'resolved', 'archived')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE public.support_messages (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    thread_id UUID REFERENCES public.support_threads(id) ON DELETE CASCADE,
    sender_id UUID REFERENCES auth.users(id) NOT NULL,
    content TEXT NOT NULL CHECK (char_length(content) > 0),
    
    -- Campos de Delimitación Contextual
    context_type support_context_type DEFAULT 'general',
    context_source_id UUID, -- El ID del registro padre (assigned_workout_id o assigned_nutrition_id)
    context_item_id UUID,   -- El ID interno del JSONB (exercise_instance_id)
    
    -- Snapshotting: Crucial para la integridad histórica
    context_snapshot JSONB, 
    
    read_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Índices para optimizar la búsqueda de historial por contexto
CREATE INDEX idx_messages_context_item ON public.support_messages(context_item_id);
CREATE INDEX idx_threads_participants ON public.support_threads(client_id, coach_id);
Justificación del Campo context_snapshot:El análisis de requisitos indica que el sistema debe ser robusto ante cambios. Si un usuario pregunta sobre una dieta de "2000 calorías" y al día siguiente el coach la cambia a "1800 calorías", la duda original pierde sentido si solo referenciamos el ID. El campo context_snapshot almacena una copia congelada de los datos (nombre del ejercicio, reps, peso, o macros de la comida) en el momento exacto en que se creó la duda.8 Esto permite al coach ver: "El usuario preguntó esto cuando el plan decía X", eliminando ambigüedades.3. Estrategia de Seguridad: Row Level Security (RLS) y Delimitación de Solo LecturaLa seguridad no se delega al frontend. Se implementa en el núcleo de la base de datos mediante Row Level Security (RLS) de PostgreSQL. Esto cumple estrictamente con el requerimiento: "haz un análisis de delimitación avanzada de que sea read only".3.1 Política de "Solo Lectura" para el ClienteEl principio de menor privilegio dicta que el cliente nunca debe tener permisos de escritura (INSERT, UPDATE, DELETE) sobre las tablas que definen su programación. Su rol es de consumo pasivo.Implementación de Políticas RLS:Workouts (assigned_workouts):SELECT: Permitido si auth.uid() == client_id. Además, se verifica que el usuario tenga una suscripción activa y el tag de acceso correspondiente (verificación cruzada con tabla profiles).INSERT/UPDATE/DELETE: Denegado implícitamente (al no crear política). Solo los roles administrativos (service_role o usuarios con tag admin) pueden escribir.9SQL-- Política de Lectura Estricta para Clientes
CREATE POLICY "Clientes leen sus propios workouts activos"
ON public.assigned_workouts
FOR SELECT
TO authenticated
USING (
    client_id = auth.uid()
    AND status = 'active'
    AND EXISTS (
        SELECT 1 FROM public.profiles
        WHERE id = auth.uid()
        AND 'workout' = ANY(access_tags) -- Validación de acceso por servicio
    )
);
Nutrición (assigned_nutrition):Sigue la misma lógica. El usuario solo ve los registros donde él es el client_id, filtrado adicionalmente por la existencia del tag nutrition en su perfil. Si un usuario tiene el plan "Fitness" (solo workouts), esta consulta retornará 0 filas, ocultando efectivamente la nutrición a nivel de API.13.2 Política de Escritura para MensajeríaA diferencia de los planes, el chat requiere escritura bidireccional. Sin embargo, la delimitación debe impedir que un usuario escriba en hilos que no le pertenecen.SQL-- Política de Inserción de Mensajes
CREATE POLICY "Usuarios escriben en sus hilos"
ON public.support_messages
FOR INSERT
TO authenticated
WITH CHECK (
    EXISTS (
        SELECT 1 FROM public.support_threads
        WHERE id = thread_id
        AND (client_id = auth.uid() OR coach_id = auth.uid())
    )
);
Esta política utiliza una subconsulta (EXISTS) para validar la propiedad del hilo antes de permitir la inserción del mensaje. Si un usuario intenta inyectar un mensaje en un thread_id ajeno, la base de datos rechazará la transacción silenciosamente o lanzará un error de violación de política, blindando la privacidad del sistema.114. Lógica de Negocio: Enrutamiento de Coach y ContextoEl requerimiento especifica: "mirará que coach estará hablando con él". Esto implica que la asignación del interlocutor no es estática ni genérica; depende del contexto de la duda (Ejercicio vs. Nutrición).4.1 Matriz de Asignación de StaffPara resolver dinámicamente quién recibe la duda, el sistema consulta la tabla staff_client_assignments (o las columnas de asignación en profiles) basándose en el context_type del mensaje.1Flujo de Resolución de Identidad:Evento: Usuario pulsa "Duda" en una comida.Detección de Contexto: La App identifica context_type = 'nutrition_meal'.Consulta de Asignación:El sistema busca en el perfil del usuario quién es su nutrition_coach_id.Si existe, ese UUID se asigna como el coach_id del hilo de conversación.Si no existe (ej. usuario básico), se asigna al general_admin o a un head_coach por defecto.Presentación Visual:La interfaz de chat carga los metadatos de ese UUID (profiles.full_name, profiles.avatar_url).El usuario ve: "Hablando con: Dra. María González (Nutrición)" en la cabecera del chat.Esta lógica desacopla al "Entrenador" del "Nutricionista", permitiendo que equipos multidisciplinarios atiendan al mismo cliente sin cruzar líneas de comunicación ni saturar a un solo profesional con todas las dudas.4.2 Experiencia de Usuario (UX) del Botón de DudaLa integración del botón debe ser omnipresente pero no intrusiva.Ubicación: En cada tarjeta de ejercicio (ExerciseCard) y cada fila de alimento (MealRow).Iconografía: Un icono de interrogación (?) o burbuja de chat discreta, situada junto al título del elemento.Comportamiento Modal:Al hacer clic, no se navega a una pantalla nueva completa (lo que perdería el contexto visual del plan), sino que se abre un Bottom Sheet (Panel deslizante inferior).Este panel contiene:Snippet de Contexto: Un resumen visual del elemento (miniatura del video, nombre del ejercicio, series/reps). Esto confirma al usuario sobre qué está preguntando.Área de Chat: Historial de mensajes previos sobre este ítem específico (si existen) y el campo de entrada de texto.Este diseño mantiene al usuario "dentro" de su entrenamiento mientras resuelve la duda.125. Arquitectura Offline-First y SincronizaciónDada la naturaleza móvil de la aplicación y el entorno de uso (gimnasios con mala señal), la aplicación no puede depender de una conexión HTTP exitosa para mostrar un plan o abrir el chat. Se requiere una arquitectura Offline-First.5.1 Motor de Sincronización Local (SQLite + WatermelonDB)La estrategia recomendada utiliza una base de datos SQLite embebida en el dispositivo del cliente, gestionada por un ORM reactivo como WatermelonDB o a través de la integración de PowerSync.13Flujo de Sincronización de Datos (Read-Only):Pull (Descarga): Al detectar conexión, el motor de sincronización solicita a Supabase todos los registros modificados desde la última sincronización (last_pulled_at).Persistencia: Los datos JSONB complejos de Workouts y Nutrición se guardan localmente en tablas SQLite.Hidratación de UI: La interfaz de usuario (React Native) se "hidrata" exclusivamente desde SQLite. Esto garantiza tiempos de renderizado inferiores a 50ms, independientemente de la red.5.2 Manejo de Mensajería Offline (Cola de Escritura)Para el chat de dudas, la experiencia debe ser fluida incluso sin red.Escritura Local: Cuando el usuario envía una duda sin conexión, el mensaje se guarda en SQLite con un flag status: 'pending'.UI Optimista: La interfaz muestra el mensaje inmediatamente en el chat, quizás con una opacidad reducida o un icono de "reloj", para dar feedback instantáneo de que la acción fue registrada.16Cola de Sincronización (Background Sync): Un worker en segundo plano monitorea el estado de la red (NetInfo). Al recuperar la conexión, itera sobre los mensajes pendientes y los envía (INSERT) a la tabla support_messages de Supabase.Resolución: Una vez que Supabase confirma la recepción (ACK), el estado local se actualiza a sent.Esta arquitectura es crítica para evitar la frustración del usuario ("El botón no funciona") en zonas muertas de cobertura.6. Análisis de Escalabilidad y Tendencias de DatosLa implementación de este sistema genera datos valiosos que van más allá del soporte inmediato.6.1 Tendencias Derivadas (Second-Order Insights)El registro granular de dudas (context_item_id) permite un análisis de datos profundo:Detección de "Puntos de Dolor" en la Programación: Si el sistema detecta que el 40% de los usuarios presiona el "Botón de Duda" en el ejercicio "Sentadilla Búlgara", esto indica una falla sistémica (video explicativo deficiente, ejercicio demasiado complejo o descripción ambigua).Evaluación de Staff: Se puede medir el tiempo de respuesta de los coaches desglosado por tipo de duda. ¿Responde el nutricionista más rápido que el entrenador?Adherencia Real: El uso del chat contextual es un proxy de compromiso. Un usuario que pregunta es un usuario que está intentando ejecutar el plan.6.2 Consideraciones de Almacenamiento JSONBEl almacenamiento de snapshots en cada mensaje (context_snapshot) duplicará datos. Sin embargo, dado el volumen de texto (bytes), el impacto en el almacenamiento es despreciable comparado con el valor de la integridad histórica. Se recomienda purgar o archivar mensajes antiguos (> 1 año) a un almacenamiento en frío ("Cold Storage") si la tabla support_messages supera los millones de registros, manteniendo la base de datos operativa ágil.67. Plan de Implementación y RecomendacionesFase 1: Migración y Estructuración (Backend)Refactorización de JSONB: Desarrollar scripts para recorrer todos los planes existentes y asignar UUIDs estables a cada bloque, ejercicio y comida. Sin esto, el chat contextual no puede funcionar retroactivamente.Despliegue de Esquema: Crear las tablas support_threads y support_messages con los tipos ENUM y las claves foráneas definidas.Configuración RLS: Aplicar las políticas de seguridad restrictivas en Supabase para bloquear la escritura directa de clientes en tablas core.Fase 2: Desarrollo Frontend (React Native)Integración de SQLite: Implementar la capa de base de datos local y la lógica de sincronización (Pull/Push).Componentes Contextuales: Modificar los componentes de renderizado de listas (FlatList) para que cada ítem reciba su context_id y renderice el "Botón de Duda".Chat UI: Construir la interfaz de chat con soporte para "Sticky Headers" contextuales y renderizado optimista de mensajes.Fase 3: Lógica Operativa (Staff)Dashboard de Coach: Actualizar el panel administrativo (WordPress/Web) para que, al recibir un mensaje, el coach vea inmediatamente el "Snippet" del ejercicio o comida en cuestión, sin tener que buscar el plan del cliente manualmente.ConclusiónLa arquitectura propuesta satisface todos los requisitos de delimitación avanzada: Read-Only estricto mediante RLS, Contextualización profunda mediante IDs estables en JSONB, e Identidad Transparente mediante enrutamiento dinámico de roles. La adopción de una estrategia Offline-First asegura que la aplicación sea robusta y rápida, transformando la experiencia de usuario de un simple visor de archivos a una herramienta de entrenamiento interactiva y profesional de alto nivel.